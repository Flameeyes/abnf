"""ABNF parser classes."""

from itertools import chain


class _IterableNode(object):  #pylint: disable=too-few-public-methods
    """Base class for Node objects.  It implements iterator and iterable methods to
    allow a single node to be treated as if it were a list of such."""

    def __init__(self) -> None:
        super(_IterableNode, self).__init__()
        self._next = False

    def __iter__(self):
        self._next = True
        return self

    def __next__(self):
        if self._next:
            self._next = False
            return self
        else:
            raise StopIteration

    def __len__(self):
        return 1

    def __eq__(self, other):
        return self.__class__ == other.__class__ and self.__dict__ == other.__dict__


class Node(_IterableNode):  #pylint: disable=too-few-public-methods
    """Node objects are used to build parse trees."""

    def __init__(self, name: str, *children: 'Node') -> None:
        super(Node, self).__init__()
        self.name = name
        self.children = children

    @property
    def value(self) -> str:
        """Returns the node value as generated by a parser."""

        return ''.join(child.value for child in self.children)

    def __str__(self) -> str:
        return 'Node(name=%s, children=[%s])' % (self.name, ', '.join(
            x.__str__() for x in self.children))


class LiteralNode(_IterableNode):  #pylint: disable=too-few-public-methods
    """LiteralNode objects are used to build parse trees."""

    def __init__(self, value, offset, length):
        super(LiteralNode, self).__init__()
        self.name = 'literal'
        self.value = value
        self.offset = offset
        self.length = length

    @property
    def children(self):
        """Returns an empty list of children, since LiteralNodes are terminal."""

        return []

    def __str__(self):
        return 'Node(name=%s, offset=%s, value="%s")' % (
            self.name, self.offset,
            self.value.replace('\r', r'\r').replace('\n', r'\n'))


class NodeVisitor(object):
    """An external visitor class."""

    def __init__(self):
        self._node_method_cache = {}

    def visit(self, node, context=None):
        return self._node_method(node)(node, context)

    @staticmethod
    def _dont_visit(node, context):
        return None

    def _node_method(self, node):
        node_name = node.name.casefold()
        try:
            node_method = self._node_method_cache[node_name]
        except KeyError:
            try:
                node_method = getattr(self, 'visit_%s' % node_name.replace('-', '_'))
            except AttributeError:
                node_method = self._dont_visit

            self._node_method_cache[node_name] = node_method

        return node_method


class ParseError(Exception):
    """Raised in response to errors during parsing."""

    pass

class GrammarError(Exception):
    """Raised in response to errors detected in the grammar."""

    pass

class Literal(object):  #pylint: disable=too-few-public-methods
    """Represents a terminal literal value."""

    def __init__(self, value, case_sensitive=False):
        """
        value is either a string to be matched, or a two-element tuple representing an
        inclusive range; e.g. ('a', 'z') matches all letters a-z.
        """
        self.value = value
        self.case_sensitive = case_sensitive
        self.pattern = value if isinstance(
            value, tuple) or case_sensitive else value.casefold()

    def parse(self, source, start):  # pylint: disable=inconsistent-return-statements
        """Parses source starting at offset start, looking for a literal string. A ParseError
        is raised if no match is found.

        :param source: source text for parsing
        :param start: offset at which to begin parsing
        :returns: LiteralNode
        :raises: ParseError
        """
        if isinstance(self.value, tuple):
            # ranges are always case-sensitive
            try:
                if self.value[0] <= source[start] and source[start] <= self.value[1]:
                    return LiteralNode(source[start], start, 1), start + 1
                else:
                    raise ParseError('Parsing error at offset %s.' % start)
            except IndexError as e:
                raise ParseError('Parsing error at offset %s.' % start) from e
        else:
            # we check position to ensure that the case pattern = '' and start >= len(source)
            # is handled correctly.
            if start < len(source):
                src = source[start:start + len(self.value)]
                match = src if self.case_sensitive else src.casefold()
                if match == self.pattern:
                    return LiteralNode(src, start, len(src)), start + len(src)
                else:
                    raise ParseError(
                        'Parsing error at offset %s.  Expected value "%s".' %
                        (start, self.value))
            else:
                raise ParseError('Parsing error at offset %s.' % start)

    def __str__(self):
        # str(self.value) handles the case value == tuple.
        non_printable_chars = set(map(chr, range(0x00, 0x20)))
        value = [
            r'\x%02x' % ord(x) if x in non_printable_chars else x
            for x in self.value
        ]
        value = tuple(value) if isinstance(self.value,
                                           tuple) else ''.join(value)
        return "Literal('%s')" % str(value)


class CharValNodeVisitor(NodeVisitor):
    def visit_char_val(self, node, context):
        """Visit a char-val node."""
        for child in node.children:
            self.visit(child, context)

    def visit_case_insensitive_string(self, node, context):
        """Visit a case-insensitive-string node."""
        context['case_sensitive'] = False
        for child in node.children:
            self.visit(child, context)

    def visit_case_sensitive_string(self, node, context):
        """Visit a case-sensitive-string node."""
        context['case_sensitive'] = True
        for child in node.children:
            self.visit(child, context)

    @staticmethod
    def visit_quoted_string(node, context):
        """Visit a quoted-string node."""
        context['value'] = node.value[1:-1]


class CharVal(Literal):  #pylint: disable=too-few-public-methods
    """A parser for literals created from a char-val node."""
    
    visitor = CharValNodeVisitor()

    def __init__(self, node):
        context = {}
        self.visitor.visit(node, context)
        try:
            super(CharVal, self).__init__(context['value'],
                                          context['case_sensitive'])
        except KeyError as e:
            raise ParseError('Invalid node %s.' % str(node)) from e


class NumVal(Literal):  #pylint: disable=too-few-public-methods
    """A parser for literals created from a num-val node."""

    range_op = '-'
    concat_op = '.'
    encoding = 'iso-8859-1'
    """encoding used to decode byte data to str."""

    def __init__(self, node):
        assert node.name == 'num-val'
        case_sensitive = True
        val_node = node.children[1]
        digit_node_name, base = self._base_info(val_node)
        data = ''
        iter_nodes = iter(val_node.children[1:])
        child_node = None
        for child_node in iter_nodes:
            if child_node.name == digit_node_name:
                data = data + child_node.value
            else:
                first_char = self._decode_bytes(data, base)
                break
        else:
            first_char = self._decode_bytes(data, base)

        data = ''

        if child_node.value == self.range_op:
            for child_node in iter_nodes:
                data = data + child_node.value
            last_char = self._decode_bytes(data, base)
            value = (first_char, last_char)
        else:
            value = first_char
            for child_node in iter_nodes:
                if child_node.name == digit_node_name:
                    data = data + child_node.value
                else:
                    value = value + self._decode_bytes(data, base)
                    data = ''
            if data:
                value = value + self._decode_bytes(data, base)

        super(NumVal, self).__init__(value, case_sensitive)

    def _decode_bytes(self, data, base):
        """Decodes num-val byte data. Intended to be private."""

        return bytearray([int(data, base=base)]).decode(self.encoding)

    @staticmethod
    def _base_info(node):
        """Returns numeric base information for node type."""

        base_info = {
            'hex-val': ('HEXDIG', 16),
            'dec-val': ('DIGIT', 10),
            'bin-val': ('BIT', 2)
        }
        return base_info[node.name]


class Alternation(object):  # pylint: disable=too-few-public-methods
    """Implements the ABNF alternation operator. -- Alternation(parser1, parser2, ...)
    returns a parser that invokes parser1, parser2, ... in turn and returns the result
    of the first successful parse.."""

    str_template = 'Alternation(%s)'

    def __init__(self, *args):
        self.args = [x for x in args]

    def parse(self, source, start):
        """
        :param source: source data
        :type str:
        :param start: offset at which to begin parsing.
        :returns: parse tree, new offset at which to continue parsing
        :rtype: Node, int
        :raises ParseError: if none of the alternation arguments can parse source
        """
        new_start = start
        for parser in self.args:
            try:
                node, new_start = parser.parse(source, new_start)
            except ParseError:
                continue
            else:
                break
        else:
            raise ParseError('Error parsing alternation at offset %s.' % start)

        return node, new_start

    def __eq__(self, other):
        return self.__class__ == other.__class__ and self.args == other.args

    def __str__(self):
        return self.str_template % ', '.join(map(str, self.args))


class Concatenation(object):  # pylint: disable=too-few-public-methods
    """Implements the ABNF concatention operation. Concatention(parser1, parser2, ...)
    returns a parser that invokes parser1, parser2, ... in turn and returns a list of Nodes
    if every parser succeeds.
    """

    str_template = 'Concatenation(%s)'

    def __init__(self, *args):
        self.args = args

    def parse(self, source, start):
        """
        :param source: source data
        :type str:
        :param start: offset at which to begin parsing.
        :returns: a List of Node objects, new offset at which to continue parsing
        :rtype: List, int
        :raises ParseError: if one of the concatenation arguments fails to parse source
        """
        nodes = []
        new_start = start
        for arg in self.args:
            try:
                node, new_start = arg.parse(source, new_start)
            except ParseError as e:
                raise ParseError('Error parsing Concatentation at offset %s.' %
                                 start) from e
            else:
                nodes.append(node)

        return chain(*nodes), new_start

    def __str__(self):
        return self.str_template % ', '.join(map(str, self.args))


class Repetition(object):  # pylint: disable=too-few-public-methods
    """Implements the ABNF Repetition operation."""

    def __init__(self, repeat, element):
        self.repeat = repeat
        self.element = element

    def parse(self, source, start):
        """
        :param source: source data
        :type str:
        :param start: offset at which to begin parsing.
        :returns: parse tree, new offset at which to continue parsing
        :rtype: Node, int
        :raises ParseError:
        """
        new_start = start
        nodes = []
        end_of_source = len(source)
        while new_start < end_of_source:
            try:
                node, new_start = self.element.parse(source, new_start)
            except ParseError:
                break
            else:
                nodes.append(node)
                if self.repeat.max and len(nodes) == self.repeat.max:
                    break

        # should write something explicit about behavior when self.element.parse returns
        # a zero-length match  -- [].
        if len(nodes) >= self.repeat.min:
            return chain(*nodes), new_start
        else:
            raise ParseError('Error parsing Repetition at offset %s.' % start)

    def __str__(self):
        return 'Repetition(%s, %s)' % (self.repeat, self.element)


class Repeat(object):  # pylint: disable=too-few-public-methods
    """Implements the ABNF Repeat operator for Repetition."""

    def __init__(self, min=0, max=None):  # pylint: disable=redefined-builtin
        self.min = min
        self.max = max

    def __str__(self):
        return 'Repeat(%s, %s)' % (self.min, self.max
                                   if max is not None else 'None')


class Option(object):  # pylint: disable=too-few-public-methods
    """Implements the ABNF Option operation."""

    str_template = 'Option(%s)'

    def __init__(self, alternation):
        self.alternation = alternation

    def parse(self, source, start):
        """
        :param source: source data
        :type str:
        :param start: offset at which to begin parsing.
        :returns: parse tree, new offset at which to continue parsing
        :rtype: Node, int
        :raises ParseError:
        """
        try:
            node, new_start = self.alternation.parse(source, start)
        except ParseError:
            node, new_start = ([], start)

        return node, new_start

    def __str__(self):
        return self.str_template % str(self.alternation)


class Rule(object):
    """A parser generated from an ABNF rule.

    To create a Rule object, use Rule.create.

    rule = Rule.create('URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]')
    """

    _obj_map = {} # type: dict

    def __new__(cls, name, definition=None):  # pylint: disable=unused-argument
        """Overrides super().__new__ to implement a symbol table via object caching.
        """

        return cls.get(name, super(Rule, cls).__new__(cls))

    def __init__(self, name, definition=None):
        obj_key = (self.__class__, name.casefold())
        if obj_key not in self._obj_map:
            self._obj_map[obj_key] = self
            self.name = name
        if definition is not None:
            # when defined-as = '=/', we'll need to overwrite existing definition.
            self.definition = definition

    def parse(self, source, start=0):
        """
        :param source: source data
        :type str:
        :param start=0: offset at which to begin parsing.
        :returns: parse tree, new offset at which to continue parsing
        :rtype: Node, int
        :raises ParseError: if source cannot be parsed using rule.
        :raises GrammarError: if rule has no definition.  This usually means that a
            non-terminal in the grammar is not defined or imported.
        """
        try:
            # ensure that rule has been defined.
            definition = self.definition
        except AttributeError as e:
            raise GrammarError('Undefined rule "%s".' % self.name) from e
        else:
            try:
                node, new_start = self.definition.parse(source, start)
            except ParseError as e:
                raise ParseError('Rule %s failed at offset %s.' %
                                 (self.name, start)) from e
            else:
                rule_node = Node(self.name, *node)
                return rule_node, new_start

    def parse_all(self, source):
        """
        Parses the source from beginning to end.  If not all of the source is consumed, a
        ParseError is raised.
        
        :param source: source data
        :type str:
        :param start=0: offset at which to begin parsing.
        :returns: parse tree
        :rtype: Node
        :raises ParseError: if source cannot be parsed using rule.
        :raises GrammarError: if rule has no definition.  This usually means that a
            non-terminal in the grammar is not defined or imported.
        """
        
        node, start = self.parse(source, 0)
        if start < len(source):
            raise ParseError('Not all source was consumed.  Unconsumed source begins at offset %s.' % start)
        return node, start            
        
    def __str__(self):
        return "%s('%s')" % (self.__class__.__name__, self.name)

    @classmethod
    def get(cls, name, default=None):
        """Retrieves Rule by name.  If a Rule object matching name is found, it is returned.
        Otherwise default is returned, and no Rule object is
        created, as would be the case when invoking Rule(name)."""

        _name = name.casefold()
        return cls._obj_map.get((cls, _name), cls._obj_map.get((Rule, _name), default))

    @classmethod
    def make_parser(cls, node: Node):
        """Creates a parser from node via invocation of some other make_parser_* method,
        following an external visitor scheme."""

        method_name = 'make_parser_%s' % node.name.replace('-', '_')
        return getattr(cls, method_name)(node)

    @classmethod
    def make_parser_alternation(cls, node: Node):
        """Creates an Alternation object from alternation node."""
        assert node.name == 'alternation'
        args = []
        for child in node.children:
            if child.name == 'concatenation':
                args.append(cls.make_parser_concatenation(child))
            else:
                continue

        return Alternation(*args) if len(args) > 1 else args[0]

    @classmethod
    def make_parser_char_val(cls, node: Node):
        """Creates a CharVal object from char-val node."""
        return CharVal(node)

    @classmethod
    def make_parser_concatenation(cls, node: Node):
        """Creates a Concatention object from concatenation node."""

        args = []
        for child in node.children:
            if child.name == 'repetition':
                args.append(cls.make_parser_repetition(child))
            else:
                continue

        return Concatenation(*args) if len(args) > 1 else args[0]

    @classmethod
    def make_parser_element(cls, node: Node):
        """Creates a parser object from element node."""

        return cls.make_parser(node.children[0])

    @classmethod
    def make_parser_elements(cls, node: Node):
        """Creates an Alternation object from elements node."""

        assert node.children[0].name == 'alternation'
        return cls.make_parser_alternation(node.children[0])

    @classmethod
    def make_parser_group(cls, node: Node):
        """Creates an Alternation object from group node."""

        for child in node.children:
            if child.name == 'alternation':
                parser = cls.make_parser_alternation(child)
                break
        else:
            assert False, 'group node has no alternation child node'
        return parser

    @classmethod
    def make_parser_num_val(cls, node) -> NumVal:
        """Creates a NumVal object from num-val node."""

        return NumVal(node)

    @classmethod
    def make_parser_option(cls, node: Node):
        """Creates an Option object from option node."""

        for child in node.children:
            if child.name == 'alternation':
                parser = cls.make_parser_alternation(child)
                break
        else:
            assert False, 'option node has no alternation child node'
        return Option(parser)

    @classmethod
    def make_parser_repeat(cls, node):
        """Creates a Repeat object from repeat node."""
        repeat_op = '*'
        min_src = '0'
        max_src = ''
        iter_child = iter(node.children)

        child = None
        for child in iter_child:
            if child.name == 'DIGIT':
                min_src = min_src + child.value
            else:
                break

        if child.value == repeat_op:
            max_src = ''
            for child in iter_child:
                max_src = max_src + child.value
        else:
            max_src = min_src

        return Repeat(
            min=int(min_src, base=10),
            max=int(max_src, base=10) if max_src else None)

    @classmethod
    def make_parser_repetition(cls, node):
        """Creates a Repetition object from repetition node."""
        if node.children[0].name == 'repeat':  # pylint: disable=no-else-return
            return Repetition(
                cls.make_parser_repeat(node.children[0]),
                cls.make_parser_element(node.children[1]))
        else:
            assert node.children[0].name == 'element'
            return cls.make_parser_element(node.children[0])

    @classmethod
    def make_parser_rule(cls, node):
        """Creates a Rule object from rule node."""
        assert node.children[0].name == 'rulename'
        rulename = node.children[0].value
        assert node.children[1].name == 'defined-as'
        for child in node.children[1].children:
            if child.name == 'literal':
                defined_as = child.value
                break
        assert node.children[2].name == 'elements'
        elements = cls.make_parser_elements(node.children[2])

        if defined_as == '=':  # pylint: disable=no-else-return
            return cls(rulename, elements)
        elif defined_as == '=/':
            rule = cls(rulename)
            rule.definition = Alternation(rule.definition, elements)
            return rule
        else:
            assert False, "Node 'defined-as' returned unexpected value %s." % defined_as
            return None

    @classmethod
    def make_parser_rulename(cls, node):
        """Returns a Rule object using value of rulename node."""
        return cls(node.value)

    @classmethod
    def create(cls, rule_source, start=0):
        """Creates a Rule object from ABNF source.  A terminating CRLF will be appended to
        rule_source if needed to satisfy the ABNF grammar rule for "rule".

        :param rule_source: the rule source.
        :type str:
        :param start=0: the offset at which to begin parsing rule_source.
        :type int:
        :returns: a Rule object (or subclass of Rule)
        :raises: ParseError
        """

        if rule_source[-2:] != '\r\n':
            rule_source = rule_source + '\r\n'
        parse_tree, start = ABNFGrammarRule('rule').parse(rule_source, start)
        return cls.make_parser_rule(parse_tree)

    @classmethod
    def rules(cls):
        """Returns a list of all rules created.

        :returns: List
        """

        return [v for k, v in cls._obj_map.items() if k[0] == cls]


# define core rules
for core_rule_def in [
    ('ALPHA', Alternation(
        Literal(('\x41', '\x5A')), Literal(('\x61', '\x7A')))),
    ('BIT', Literal(('\x30', '\x31'))),
    ('CHAR', Literal(('\x01', '\x7F'))),
    ('CTL', Alternation(Literal(('\x00', '\x1F')), Literal('\x7F'))),
    ('CR', Literal('\x0D')),
    ('CRLF', Concatenation(Rule('CR'), Rule('LF'))),
    ('DIGIT', Literal(('\x30', '\x39'))),
    ('DQUOTE', Literal('\x22')),
    ('HEXDIG',
     Alternation(
         Rule('DIGIT'), Literal('A'), Literal('B'), Literal('C'), Literal('D'),
         Literal('E'), Literal('F'))),
    ('HTAB', Literal('\x09')),
    ('LF', Literal('\x0A')),
    ('LWSP',
     Repetition(Repeat(),
                Alternation(
                    Rule('WSP'), Concatenation(Rule('CRLF'), Rule('WSP'))))),
    ('OCTET', Literal(('\x00', '\xFF'))),
    ('SP', Literal('\x20')),
    ('VCHAR', Literal(('\x21', '\x7E'))),
    ('WSP', Alternation(Rule('SP'), Rule('HTAB'))),
]:
    Rule(*core_rule_def)


# define grammar rules
class ABNFGrammarRule(Rule):
    """Rules defining ABNF in ABNF."""

    grammar = [] # type: list


ABNFGrammarRule.grammar = [
    ('rulelist',
     Repetition(
         Repeat(1),
         Alternation(
             ABNFGrammarRule('rule'),
             Concatenation(
                 Repetition(Repeat(), ABNFGrammarRule('c-wsp')),
                 ABNFGrammarRule('c-nl'))))),
    ('rule',
     Concatenation(
         ABNFGrammarRule('rulename'), ABNFGrammarRule('defined-as'),
         ABNFGrammarRule('elements'), ABNFGrammarRule('c-nl'))),
    ('rulename',
     Concatenation(
         Rule('ALPHA'),
         Repetition(Repeat(),
                    Alternation(Rule('ALPHA'), Rule('DIGIT'), Literal('-'))))),
    ('defined-as',
     Concatenation(
         Repetition(Repeat(), ABNFGrammarRule('c-wsp')),
         Alternation(Literal('=/'), Literal('=')),
         Repetition(Repeat(), ABNFGrammarRule('c-wsp')))),
    ('elements',
     Concatenation(
         ABNFGrammarRule('alternation'),
         Repetition(Repeat(), ABNFGrammarRule('c-wsp')))),
    ('c-wsp',
     Alternation(
         Rule('WSP'), Concatenation(ABNFGrammarRule('c-nl'), Rule('WSP')))),
    ('c-nl', Alternation(ABNFGrammarRule('comment'), Rule('CRLF'))),
    ('comment',
     Concatenation(
         Literal(';'),
         Repetition(Repeat(), Alternation(Rule('WSP'), Rule('VCHAR'))),
         Rule('CRLF'))),
    ('alternation',
     Concatenation(
         ABNFGrammarRule('concatenation'),
         Repetition(Repeat(),
                    Concatenation(
                        Repetition(Repeat(), ABNFGrammarRule('c-wsp')),
                        Literal('/'),
                        Repetition(Repeat(), ABNFGrammarRule('c-wsp')),
                        ABNFGrammarRule('concatenation'))))),
    ('concatenation',
     Concatenation(
         ABNFGrammarRule('repetition'),
         Repetition(Repeat(),
                    Concatenation(
                        Repetition(Repeat(1), ABNFGrammarRule('c-wsp')),
                        ABNFGrammarRule('repetition'))))),
    ('repetition',
     Concatenation(
         Option(ABNFGrammarRule('repeat')), ABNFGrammarRule('element'))),
    ('repeat',
     Alternation(
         Concatenation(
             Repetition(Repeat(), Rule('DIGIT')), Literal('*'),
             Repetition(Repeat(), Rule('DIGIT'))),
         Repetition(Repeat(1), Rule('DIGIT')))),
    ('element',
     Alternation(
         ABNFGrammarRule('rulename'), ABNFGrammarRule('group'),
         ABNFGrammarRule('option'), ABNFGrammarRule('char-val'),
         ABNFGrammarRule('num-val'))),  # prose-val omitted for now.
    ('group',
     Concatenation(
         Literal('('), Repetition(Repeat(), ABNFGrammarRule('c-wsp')),
         ABNFGrammarRule('alternation'),
         Repetition(Repeat(), ABNFGrammarRule('c-wsp')), Literal(')'))),
    ('option',
     Concatenation(
         Literal('['), Repetition(Repeat(), ABNFGrammarRule('c-wsp')),
         ABNFGrammarRule('alternation'),
         Repetition(Repeat(), ABNFGrammarRule('c-wsp')), Literal(']'))),
    ('num-val',
     Concatenation(
         Literal('%'),
         Alternation(
             ABNFGrammarRule('bin-val'), ABNFGrammarRule('dec-val'),
             ABNFGrammarRule('hex-val')))),
    ('bin-val',
     Concatenation(
         Literal('b'),
         Concatenation(
             Repetition(Repeat(1), Rule('BIT')),
             Option(
                 Alternation(
                     Repetition(
                         Repeat(1),
                         Concatenation(
                             Literal('.'), Repetition(Repeat(1),
                                                      Rule('BIT')))),
                     Concatenation(
                         Literal('-'), Repetition(Repeat(1),
                                                  Rule('BIT')))))))),
    ('dec-val',
     Concatenation(
         Literal('d'),
         Concatenation(
             Repetition(Repeat(1), Rule('DIGIT')),
             Option(
                 Alternation(
                     Repetition(
                         Repeat(1),
                         Concatenation(
                             Literal('.'), Repetition(
                                 Repeat(1), Rule('DIGIT')))),
                     Concatenation(
                         Literal('-'), Repetition(Repeat(1),
                                                  Rule('DIGIT')))))))),
    ('hex-val',
     Concatenation(
         Literal('x'),
         Concatenation(
             Repetition(Repeat(1), Rule('HEXDIG')),
             Option(
                 Alternation(
                     Repetition(
                         Repeat(1),
                         Concatenation(
                             Literal('.'), Repetition(
                                 Repeat(1), Rule('HEXDIG')))),
                     Concatenation(
                         Literal('-'), Repetition(Repeat(1),
                                                  Rule('HEXDIG')))))))),
    # definitions from RFC 7405
    ('char-val',
     Alternation(
         ABNFGrammarRule('case-insensitive-string'),
         ABNFGrammarRule('case-sensitive-string'))),
    ('case-insensitive-string',
     Concatenation(Option(Literal('%i')), ABNFGrammarRule('quoted-string'))),
    ('case-sensitive-string',
     Concatenation(Literal('%s'), ABNFGrammarRule('quoted-string'))),
    ('quoted-string',
     Concatenation(
         Rule('DQUOTE'),
         Repetition(Repeat(),
                    Alternation(
                        Literal(('\x20', '\x21')), Literal(('\x23', '\x7E')))),
         Rule('DQUOTE'))),
]

for grammar_rule_def in ABNFGrammarRule.grammar:
    ABNFGrammarRule(*grammar_rule_def)
